#include "graph.h"

int t;

//Constructor that uses an input stream to create the graph and its vertices and edges
Graph :: Graph(std::ifstream &inFile) {
  numEdges = 0;
  numVertex = 0;
  std::string input;
  std::stringstream ss; //used to seperate each integer from a string generated by getline
  int x;
  int y;
  std::getline(inFile, input);
  if(input.compare("true") == 0) { //reads if the graph is directed or not
    direct = true;
  }
  else {
    direct = false;
  }
  std::getline(inFile, input); //Adds vertices
  ss << input;
  while(!ss.eof()) {
    ss >> x;
    addVertex(x);

  }
  while(getline(inFile, input)) { //adds edges
    std::stringstream ss(input);
    ss >> x;
    std::getline(inFile, input);
    std::stringstream ss2(input);
    while(ss2 >> y) {
      addEdge(x,y);
    }
  }
  std::cout << std::endl;
}

//Constructor with a bool thats used to determine if its directed or not
Graph :: Graph(bool d) {
  if(d) {
    direct = true;
  }
  else {
    direct = false;
  }
}

//Copy Constructor that transposes G
Graph :: Graph(const Graph& original) {
  direct = original.direct;
  cycle = original.cycle;
  for(auto it = original.vertices.begin(); it != original.vertices.end(); it++) {
    addVertex(it->first);
  }
  for(auto it = original.vertices.begin(); it != original.vertices.end(); it++) {
    for(int n : it->second) {
      addEdge(n, it->first);
    }
  }
}

void Graph :: addVertex(int x) {
  if(vertices.find(x) == vertices.end()) { //Searches the map for vertex x

  std::vector<int> neighbors; //if not found initalize an empty vector
  vertices.insert({x, neighbors}); //insert x and its empty vector into the map
  color.insert({x, nil});
  discover.insert({x, NULL});
  finish.insert({x, NULL});
  predecesor.insert({x, NULL});
  numVertex++;
  }
  else {
    std::cout << "Vertex " << x << " is already in the graph."  << "\n"<< std::endl; //if already found print statement
  }
}

//Takes in two integers that correspond to vertices on a graph. A search is done on each integer to make sure its a valid
//vertex. If valid, the addEdge function is called which adds each vertex to the others adjacency list if undirected and if
//directed, adds y to x's ajacency list. An error message is thrown if the edge already exists or the vertices are not valid.
void Graph :: addEdge(int x, int y) {
  auto it = vertices.find(x); //iterators that are set to where x and y are in the map if found
  auto it2 = vertices.find(y);
  bool exist = false; //bool acting as a flag for inserting an edge
  if(it != vertices.end() && it2 != vertices.end()) //If statement to check if both vertices are in the graph
  {
    for(int n : it->second) { //for loop that checks adjacency list of x. if y is found then the edge already exists
      if(n == y) {            //Only need to check one list since this is an undirected graph
        std::cout << "An edge between the vertices, " << x << " and " << y << ", already exists." << "\n" << std::endl;
        exist = true; //if they exist the flag is set to true
      }
    }
    if(!exist) { //if bool is false then the edge is added by means of inserting x into y's adjacency list and vice versa.
      if(direct) { //If a directed graph an edge is added from x to y
        vertices[x].push_back(y);
      }
      else { //If its undirected an edge is added to both
        vertices[x].push_back(y);
        vertices[y].push_back(x);
        numEdges++;
        std::pair<int,int> edge;
        edge.first = x;
        edge.second = y;
        edges.insert({numEdges, edge});
      }
    }
  }
  else {
    std::cout << "Error. One or both of the requested verticies are not in the graph." << "\n" << std::endl;
  }
}

void Graph :: print() { //Prints a vertex, and all of its neighbors
  for(auto it = vertices.begin(); it != vertices.end(); it++) { //For loop is set to the first vertex in the map
    std::cout << "Neighbors of vertex " << it->first <<std::endl; //it->first points to the key which is the value of the vertex
    if(it->second.empty()) //it->second points to the vector or the adjaceny list of all the neighboring vertices
    {
      std::cout << "\nThis vertex has no neighbors" << std::endl;
    }
    else {
      for(int n : it->second) { //ranged based for loop that iteratates through the vector
        std::cout << n << " ";
      }
      std::cout << "\n" << std::endl;
    }
  }
}

//Depth First Search creates all the data needed for the map private members, finish and discover
void Graph :: DFS() {
  for(auto it = vertices.begin(); it != vertices.end(); it++) { //All vertices are colored white at first
    color[it->first] = white;
    predecesor[it->first] = 0;
  }

  t = 0;
  for(auto it = vertices.begin(); it != vertices.end(); it++) { //iterates through each vertex in the graph
    if(color[it->first] == white) {
      DFSVisit(it->first);
    }
  }

}

//Visits all vertices in a Vertex's adjaceny list and calculates discover and finish times
void Graph :: DFSVisit(int u) {
  t = t + 1;
  discover[u] = t;
  color[u] = grey; //When discovered the vertex is colored grey
  auto it = vertices.find(u); //iterates through all vertex adjaceny list
  for(int v : it->second) {
    if(color[v] == white) { //if any are undiscovered recursively call DFSVisit on that vertex
      predecesor[v] = u;
      DFSVisit(v);
    }
    if(color[v] == grey && predecesor[v] != u) { //if any vertex v whose predecessor isnt u is colored grey a cycle is found
      cycle = true;
    }
  }
  color[u] = black; //u is colored black once fully discovered
  t = t + 1;
  finish[u] = t;
}

//Exactly the same as DFSVisit but prints the nodes as they are discovered for Strongly Connected Components
void Graph :: PrintDFSVisit(int u) {
  t = t + 1;
  discover[u] = t;
  std::cout << u << " ";
  color[u] = grey;
  auto it = vertices.find(u);
  for(int v : it->second) {
    if(color[v] == white) {
      predecesor[v] = u;
      PrintDFSVisit(v);
    }
    if(color[v] == grey && predecesor[v] != u) {
      cycle = true;
    }
  }
  color[u] = black;
  t = t + 1;
  finish[u] = t;
}

//Determines if there the graph has any strongly connected components and prints them if they do
void Graph :: SCC() {
  if(direct) {
    DFS();
    std::cout << "Printing out Strongly Connected Components" << std::endl;
    Graph gt = *this;
    for(auto it = gt.vertices.begin(); it != gt.vertices.end(); it++) {
      gt.color[it->first] = white;
      gt.predecesor[it->first] = -9999;
    }

    t = 0;
    std::map<int,int> copy = finish; //Copy of G finish times from DFS
    while(copy.empty() != true) { //While copy isnt empty, find the largest time than do GTransposed.DFS on that vertex
      int greatest = copy.begin()->second;//greatest is set to first pair in map
      int vertex = copy.begin()->first; //keeps track of what vertex to call DFSVisit with
      for(auto it = copy.begin()++; it != copy.end(); it++) { //Iterates through copy of finish times and notes the largest
        if(it->second > greatest) {                           //gets smaller by 1 each time
          greatest = it->second;
          vertex = it->first;
        }
      }
      if(gt.color[vertex] == white) { //Second half of DFS if White do GT.DFSVisit on vertex
        gt.PrintDFSVisit(vertex);
        std::cout << std::endl;
      }
      copy.erase(vertex); //delete the largest from the copy of the map
    }
  }
  else {
    std::cout << "There are no strongly connected components since the graph is undirected." << std::endl;
  }
}

//Prints out what type of graph, directed or undirected
void Graph :: whatGraph() {
  if(direct) {
    std::cout << "This is a directed graph!" << std::endl;
  }
  else {
    std::cout << "This is an undirected graph!" << std::endl;
  }
}

//Determines if the graph is a dag or not, must call DFS on the graph first
void Graph :: CheckIfDag() {
  if(!cycle && direct) {
    std::cout << "The graph is a DAG" << std::endl;
  }
  else {
    std::cout << "The graph is not a DAG" << std::endl;
  }
}

//Prints out the vertices of G in a topolgical sort if possible
void Graph :: TopoSort() {
  if(direct && !cycle) {
    if(finish.empty() == true) {
      DFS();
    }
    std::cout << "Topological Sort of the Graph: ";
    std::map<int, int> copy = finish;
    while(copy.empty() != true) { //While copy isnt empty, find the largest time than do GTransposed.DFS on that vertex
      int greatest = copy.begin()->second;//greatest is set to first pair in map
      int vertex = copy.begin()->first; //keeps track of what vertex to call DFSVisit with
      for(auto it = copy.begin()++; it != copy.end(); it++) { //Iterates through copy of finish times and notes the largest
        if(it->second > greatest) {                           //gets smaller by 1 each time
          greatest = it->second;
          vertex = it->first;
      }
    }
    std::cout << vertex << " ";
    copy.erase(vertex); //delete the largest from the copy of the map
    }
  }
  else {
    std::cout << "No topological sort of this graph exists due to it not being a DAG." << std::endl;
  }
  std::cout << std::endl;
}

//Prints the metadata that was found during DFS
void Graph :: printDFSData() {
  std::cout << "Data from a DPS" << std::endl;
  for(auto it = vertices.begin(); it != vertices.end(); it++) {
    auto start = discover.find(it->first);
    auto end = finish.find(it->first);
  std::cout << "Vertex: " << it->first << " Discovered: " << start->second << " Finished: " << end->second << std::endl;
  }
}

//Prints the edge number followed by what vertices each edge connects
void Graph :: printEdges() {
  std::cout << "Number of Edge: " << numEdges << std::endl;
  for(auto it = edges.begin(); it != edges.end(); it++) {
    std::cout << "Edge: " << it->first << " Vertices: " << it->second.first << " " << it->second.second << std::endl;
  }
}

//Prints the vertices that are used for a vertexCover
void Graph :: vertexCover() {
  std::set<int> s;
  std::map<int, std::pair<int,int>> edgeCopy;
  edgeCopy = edges;
  while (!edgeCopy.empty()) {

    auto it = edgeCopy.begin();
    if(edgeCopy.size() == 1) {
      s.insert(it->second.first);
    }
    else {
      s.insert(it->second.first);
      s.insert(it->second.second);
      for(auto iter = edgeCopy.begin(); iter != edgeCopy.end(); ) {
        if(iter->second.first == it->second.first || iter->second.first == it->second.second || iter->second.second == it->second.first || iter->second.second == it->second.second) {
          iter = edgeCopy.erase(iter);
        }
        else {
          iter++;
        }
      }
    }
  }
  //Prints out the vertex cover
  for(int n : s) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

//Prints the vertices used in a vertexCover but each edge is chosen randomly
void Graph :: randomVertexCover() {
  srand(time(0));
  std::set<int> s;
  std::map<int, std::pair<int,int>> edgeCopy;
  edgeCopy = edges;
  while (!edgeCopy.empty()) {
    int size = edgeCopy.size(); //size of the edge copy
    auto it = edgeCopy.begin(); //iterator initalized
    if(size == 1) {
      s.insert(it->second.first);
    }
    else {
      if(size > 1) { //if more than one edge remains randomly select an edge
        std::vector<int> random; //vector that stores all the edges remaining
        for(auto i = edgeCopy.begin(); i != edgeCopy.end(); i++) {
          random.push_back(i->first); //populating the vector
        }
        int index = rand() % (size-1); //random number between 0 and n-1 which is the length of the edge map
        it = edgeCopy.find(random[index]); //iterator that points to the edge in the edge map determined via random
      }
      s.insert(it->second.first); //vertices of the edge are stored in a set s
      s.insert(it->second.second);
      for(auto iter = edgeCopy.begin(); iter != edgeCopy.end(); ) { //deleting any edge that is connected to the vertices
        if(iter->second.first == it->second.first || iter->second.first == it->second.second || iter->second.second == it->second.first || iter->second.second == it->second.second) {
          iter = edgeCopy.erase(iter);
        }
        else {
          iter++;
        }
      }
    }
  }
  //Prints out the vertexCover
  for(int n : s) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

void Graph :: shuffleEdges(std::map<int,std::pair<int,int>> &e) {
  std::vector<int> keys;
  for(auto it = e.begin(); it != e.end(); it++) {
    keys.push_back(it->first);
  }
}

void Graph :: trueMin() {
  std::vector<int> v;

  for(auto it = vertices.begin(); it != vertices.end(); it++) { //vertices are put into a vector
    v.push_back(it->first);
  }

  for (int i = 1; i < numVertex-1; i++) {

  }
}
